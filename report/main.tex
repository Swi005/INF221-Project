\documentclass{article}

\usepackage{graphicx} % Required for inserting images
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{float}
\usepackage{listings}



\title{Parser Generators are Hard}
\author{Sander Wiig}
\date{\today}

\begin{document}

\maketitle

%\tableofcontents

%\section{Proof of man's Hubris}
\section{Project Description}
\subsection{Project}
I believe it was Mark Twain who once said, "\textit{Challenges make life interesting}"; by that standard, my life has been very interesting.\\

The project's original goal was to create a metalanguage for defining other languages.
The plan was to have an underlying semantics and then to let the user define a syntax and give bindings between that syntax and the underlying semantics.
It turns out that this is somewhat difficult to achieve.\\
Therefore, the project goal was scaled back to just a parser generator that outputs a parser that can parse a CFG grammar and an AST for said grammar.\\

It turns out this also presents some challenges. 
An AST is very much just a parse tree but with all the superfluous information, such as parenthesis, semicolons, and other non-relevant information, removed so that all that remains is the information necessary to preserve the semantics and structure of the program. 
The problem then becomes, What information is relevant? 
Because of this, the output was changed from an AST to a parse tree.\\

This is where the project is now.
The project is a parser generator that takes a CFG grammar(in a format similar to EBNF) and outputs a parser that can parse a program written in the user-defined grammar and outputs a parse tree for that program.


\subsection{The Parser Generator}
The parser generator works by first parsing a \texttt{.ebnf} file. The \texttt{.ebnf} file contains a CFG grammar that is defined in a format inspired by EBNF.
The EBNF parser outputs an AST representation of the grammar that is then fed to the code generator. Both the grammar parser and the generated parser make use of the Haskell library Mega parsec.
MegaParsec is a monadic parser library for Haskell, it is a fork of the Parsec library\cite{megaparsec}.\\  

\begin{figure}[H]
    \centering
    \fbox{
        \centering
        \begin{tikzcd}
                \parbox{\textwidth}{\centering \texttt{.ebnf} file}\arrow[d, ""]\\
                \fbox{\parbox{10em}{\centering EBNF Parser}}\arrow[d, "AST"]\\
                \fbox{\parbox{10em}{\centering Static Analyizer}}\arrow[d, "AST"]\\
                \fbox{\parbox{10em}{\centering Code Generator}}\arrow[d, ""]\\
                \parbox{\textwidth}{\centering \text{Parser Code}}
        \end{tikzcd}
    }
    \caption{The Parser Generator Process}
    \label{fig:process}
\end{figure}

One early challenge in writing the parser was parsing infix notation. This was resolved by using the \texttt{makeExprParser} from parses-combinators\cite{parsercombinators}, a companion library to MegaParsec.\\
This did not solve the problem since the problem would still occur in the generated parser as well, and it would be too complicated to try to identify infix notation in the user grammar.\\

\subsection{Program internals}
The library consists of two sub-libraries,
    \begin{itemize}
        \item \textbf{EBNF} - The \texttt{EBNF} library is responsible for parsing the user-defined grammar and creating an AST for it.
        \item \textbf{Generator} - The \texttt{Generator} takes an AST generated by the \texttt{EBNF} library and generates a Megaparsec parser that can parse a user-defined grammar. 
    \end{itemize}

There is also a folder containing example grammar (including the EBNF grammar itself) and code for running the tests.

\subsubsection*{EBNF}
The \texttt{EBNF} library consists of the following files
\begin{itemize}
    \item \texttt{CheckGrammar.hs} - contains functions for checking the grammar for errors.
    \item \texttt{EBNF.hs} - contains the AST for a grammar.
    \item \texttt{Lexer.hs} - contains helper functions for tokenizing the input.
    \item \texttt{Parser.hs} - contains the parser for the user-defined EBNF grammar.
    \item \texttt{REGEX.hs} - contains the AST and parser for regular expression, not implemented into the program yet.
\end{itemize}


\subsubsection*{Generator}
The \texttt{Generator} library consists of the following files
\begin{itemize}
    \item \texttt{Generator.hs} - contains functions for generating Haskell code from an EBNF AST.
    \item \texttt{GenUtils.hs} - contains helper functions for generating Haskell code, such as generating Haskell headers and imports, and commonly used code.
    \item \texttt{ParseTree.hs} - defines a simple parse tree. 
\end{itemize}

\subsection*{Techniques and libraries}
Most of the project is built on megaparsec.
The project makes heavy use of \texttt{Control.Applicative} to implement the Parsers.\\
An attempt was also made to implement parse trees using free monoids from the library free\cite{free}. \\
This was abandoned because I couldn't find out how they worked, and I didn't see the advantage over a normal tree.\\
The library \texttt{pretty-simple} was used to pretty print ASTs and other data structures\cite{pretty}.


The techniques and libraries used seem to have been fitting, I can not think of any other techniques that would have been useful.



\section{Does it work?}
\subsection{"There are 56 consecutive parentheses"}
    Unfortunately, the parser generator does not quite work as intended\dots\\
    While it can parse a grammar and generate a parser for it, the parser it generates is only functional for the smaller grammars(ex1, ex2, etc). 
    When given the final test, the EBNF grammar itself ends up generating some \textit{interesting} code....: \newpage
    \begin{figure}[H]
            \begin{lstlisting}[language=Haskell]
return (Symbol "letter" [((((((((((((((((((((((((((((((((((((((((((((((((((
    (Literal $ symbol "A") <|> (Literal $ symbol "B")) <|> 
    (Literal $ symbol "C")) <|> (Literal $ symbol "D")) <|> 
    (Literal $ symbol "E")) <|> (Literal $ symbol "F")) <|> 
    (Literal $ symbol "G")) <|> (Literal $ symbol "H")) <|> 
    (Literal $ symbol "I")) <|> (Literal $ symbol "J")) <|> 
    (Literal $ symbol "K")) <|> (Literal $ symbol "L")) <|> 
    (Literal $ symbol "M")) <|> (Literal $ symbol "N")) <|> 
    (Literal $ symbol "O")) <|> (Literal $ symbol "P")) <|> 
    (Literal $ symbol "Q")) <|> (Literal $ symbol "R")) <|> 
    (Literal $ symbol "S")) <|> (Literal $ symbol "T")) <|> 
    (Literal $ symbol "U")) <|> (Literal $ symbol "V")) <|> 
    (Literal $ symbol "W")) <|> (Literal $ symbol "X")) <|> 
    (Literal $ symbol "Y")) <|> (Literal $ symbol "Z")) <|> 
    (Literal $ symbol "a")) <|> (Literal $ symbol "b")) <|> 
    (Literal $ symbol "c")) <|> (Literal $ symbol "d")) <|> 
    (Literal $ symbol "e")) <|> (Literal $ symbol "f")) <|> 
    (Literal $ symbol "g")) <|> (Literal $ symbol "h")) <|> 
    (Literal $ symbol "i")) <|> (Literal $ symbol "j")) <|> 
    (Literal $ symbol "k")) <|> (Literal $ symbol "l")) <|> 
    (Literal $ symbol "m")) <|> (Literal $ symbol "n")) <|> 
    (Literal $ symbol "o")) <|> (Literal $ symbol "p")) <|> 
    (Literal $ symbol "q")) <|> (Literal $ symbol "r")) <|> 
    (Literal $ symbol "s")) <|> (Literal $ symbol "t")) <|> 
    (Literal $ symbol "u")) <|> (Literal $ symbol "v")) <|> 
    (Literal $ symbol "w")) <|> (Literal $ symbol "x")) <|> 
    (Literal $ symbol "y")) <|> (Literal $ symbol "z")])
            \end{lstlisting}
    \end{figure}
    
    This example above is the parser for a letter character. 
    Since the ebnf parser parses this as a sequence of \texttt{OR}s 
    and because the parser generator defines the parser for \texttt{OR} as
    \begin{lstlisting}
        (e1) <|> (e2)
    \end{lstlisting}
     we end up with 56 parentheses.
\subsection{How to make it work}
    Most problems would be solved by performing a static analysis of the grammar to resolve possible problems.
    Right now very little static analysis is performed on the grammar, ideally, the grammar would be checked to make sure that it was free from ambiguities,
    this could be done by attempting to build a PDA from the grammar. 

\section{How to Use it}
\subsection{Generating a Parser}
To generate a grammar one can use the \texttt{generate} function in \texttt{GenParser.hs}.
\texttt{generate} takes a grammar \texttt{string} and returns the parser in string form.

See the \texttt{test} function in \texttt{test/GeneratorTest.hs} for an example of how to use the different functions.

\subsection{Using the generated parser}
After using \texttt{generate} and writing the string to a file you can use the parsers in the file as needed.



\bibliographystyle{acm}
\bibliography{refs}
    
\end{document}
